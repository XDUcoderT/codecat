---
title: 计组
permalink: /post/plan-2imk0c.html
date: 2023-03-14 22:23:26
meta:
  - name: keywords
    content: ''
  - name: description
    content: >-
      计组绪论与cpu性能相关的几个问题相应时间响应时间是指计算机完成某一任务所耗费的全部时间。显然响应时间里包括为完成任务对磁盘的访问内存的访问io操作操作系统的开销等。两台计算机a和b如果说a比b快就是说对于给定的任务a的响应时间比b的响应时间短。通常计算机a比计算机b快n倍可用下式表示_n＝计算机b的响应时间计算机a的响应时间cpu时间cpu时间＝总的时钟周期数×时钟周期长度或cpu时间＝总的时钟周期数时钟频率另外我们一定能够知道上面某一程序有多少条指令假定上面的程序有ic条指令执行用的总时钟周期数也是知
tags: []
categories: []
author:
  name: terwer
  link: https://github.com/XDUcoderT
---

# 计组

# 绪论

## 与CPU性能相关的几个问题

1. 相应时间

    响应时间是指计算机完成某一任务所耗费的全部时间。显然，响应时间里包括 为完成任务对磁盘的访问、内存的访问、I/O 操作、操作系统的开销等。两台计算机 A 和 B，如果说 A 比 B 快，就是说对于给定的任务，A 的响应时间比 B 的响应时间短。通常，计算机 A 比计算机 B 快 n 倍可用下式表示：

    n＝ 计算机B的响应时间/计算机A的响应时间
2. CPU时间

    CPU 时间＝总的时钟周期数×时钟周期长度 

    或 

    CPU 时间＝总的时钟周期数/时钟频率

    另外，我们一定能够知道上面某一程序有多少条指令，假定上面的程序有 IC 条 指令，执行用的总时钟周期数也是知道的，则就可以计算出一条指令从头到尾处理完的平均时钟周期数 ​CPI：  CPI＝总的时钟周期数/IC

    CPU 时间＝IC×CPI×时钟周期长度

    或 

    CPU 时间＝IC×CPI/时钟频率

    假定在计算机系统中有 n 种指令，其中第 i 种指令的处理时间为 CPIi ，在程序 中第 i 种指令的出现次数为 ICi ，则程序执行的 CPU 时间可用下式计算

    ​![image](assets/image-20230319105926-tbdiv2z.png)​
3. Amdahl定律

计算机系统中某一部件由于采用某种更快的执行方式后，整个系统性能的提高与这种执行方式的使用频率或占总执行时间的比例有关。

加速比 ＝ 改进后的系统性能 / 改进前的系统性能

 	     =  改进前的系统总执行时间 / 改进后的系统总执行时间

计算机系统的的加速比取决于下面两个因素： 

①可改进部分在原系统总执行时间中所占的比，称为可改进比例，用 fe表示。 例如，程序的总执行时间为 100s，可改进的部分是其中的 20s，则 fe＝0.2。可见， fe 总是小于或等 1 的。 

②可改进部分改进后性能提高的程度，通常用部件加速比 re 来表示某部件改进 后性能提高的比例。例如，某部件改进后，执行时间由原来的 20s 减少到 5s，则部 件加速比 re＝20/5＝4。可见，re一般是大于 1 的。

总体加速比 = 1  /  （1 - 加速部件比例 + 部件加速比例/部件加速比）

> 例 1.1 某计算机系统的某一部件的处理时间为总处理时间的 40％，该部件改进 后部件加速比为 10，试计算改进后系统的加速比 Sp为多少。 
>
> 解：由上述题意可知，fe＝0.4，re＝10，则 Sp＝1/［（1－0.4）＋0.4/10］≈1.56

# 计算机中的数据表示

## 数据编码

### 概述

#### 1. 进制转换

这个不是很难其实 参考数电内容

#### 2. 无符号数和有符号数

1. 无符号数

    所谓无符号数即没有符号的数，数中的每一位均用来表示数值。所以，8 位二进制无符号数所表示的数值范围是 0～255。而 16 位无符号数的表示范围为 0～ 65535。

2. 有符号数

    对有符号数而言，由于机器是无法直接识别“+、－”（即正、“负）符号，但 由于“正”、“负”恰好是两种截然不同的状态，若用“0”表示“正”，用“1” 表示“负”，则符号也被数字化了。并且规定将符号放在有效数字的前面，这样就 组成了有符号数。

#### 3. 定点数和浮点数

1. 定点数

    在数据的机器表示中，若约定小数点的位置固定不变，则称为定点数。有两种形式的定点数：定点整数（纯整数，小数点定在最低有效数值位之后）和定点小数 （纯小数，小数点在最高有效数值位之前。

    ​![image](assets/image-20230314223544-2wjuyun.png)​
2. 浮点数

    基数为 2 的数 F 的浮点表示为： F = M×2^E 其中 M 称为尾数，E 称为阶码。 尾数为带符号的纯小数，阶码通常为带符号的纯整数。

    ​![image](assets/image-20230314223711-te4cxcs.png)​

### 原码

#### 1. 整数原码

符号位 + 数值位 ​

符号位：0表示正数 1表示负数

数值位：真值的绝对值

​![image](assets/image-20230314223939-ol61b81.png)​

> 例 1：
>
> 当 X=+35 时，若用 8 位二进制编码的原码表示，则 [X]原 =00100011 
>
> 若 X=－35，同样用 8 位编码表示，则 [X]原 =10100011 
>
> 从上面的定义可以看到，符号位总是放在最高位。

#### 2. 小数原码

和整数类似，只不过符号位在小数点前面

符号位：0表示正数 1表示负数

数值位：真值的绝对值

**纯小数的原码表示可以表示为：**

对于正数：[X]原＝0.X1X2„Xn－1

对于负数：[X]原＝1.X1X2„Xn－1

> 例 2：
>
> 若纯小数 X＝0.46875，用包括符号位为 8 位的定点原码表示，则可表示为： [X]原 =0.0111100 
>
> 若纯小数 X＝－0.46875，用包括符号位的定点原码表示，则可表示为： [X]原 =1.0111100

‍

### 补码

#### 整数补码

​![image](assets/image-20230314224849-736wajn.png)​

正数 ：补码 = 原码

负数： 补码 = 原码不包括符号位各位取反，再在最低位上加 1。

#### 小数补码

​![image](assets/image-20230314225255-xib9rxl.png)​

> 例 3：
>
> 若纯小数 X＝0.46875，用包括符号位的 8 位定点补码表示，则可表示为： [X]补 =0.0111100 可以看到，对于正数，补码纯小数表示与原码是一样的。
>
> 对于负数纯小数，构 成其补码表示形式所采用的方法与整数一样。
>
> 因此，当 X＝－0.46875 时，用包括符号位的 8 位定点补码表示，则可表示 为： [X]补 =1.1000100

#### 补码特点

1. 0的表示是唯一的

    [+0]补 =0.0000000  [-0]补 =2+（-0.0000000）=10.0000000-0.0000000=0.0000000 显然[+0]补 =[-0]补=0.0000000，即补码中的“零”只有一种表示形式。
2. 变形码

    当模数为 4 时，形成了双符号位的补码，如 X=－0.1001，对（mod 2^2）而言。

     [X]补= 2^2 +X=100.0000000-0.1001000=11.0111000

    这种双符号位的补码又叫做变形补码，它在阶码运算和溢出判断中，有其特殊作用。
3. 求补运算

    具体运算就是将操作数，包括符号位在内，各位取反再在最低位上加上 1。
4. 简化加减法

    利用补码实现两数相加是很方便的，补码加法的运算法则为：                                      ［X＋Y］补＝［X］补＋［Y］补

    两数和的补码就等于两数补码之和

    对补码求补就相当于在其前面加了一个负号。 也就是说［［X］补］求补＝［－X］补；［［－X］补］求补＝［X］补

就是说，一个数补码再求补这个数相反数的补码

> 例 4：欲求 68－35＝？
>
> 可以将上式写作：68＋（－35）＝Z，
>
> 则  [Z]补＝[68]补＋[（－35）]补＝01000100＋11011101＝00100001 所获得的结果正是 33。

**总结：补码具有加法可拆性**

### 移码



‍

‍
